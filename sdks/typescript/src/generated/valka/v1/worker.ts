// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.21.12
// source: valka/v1/worker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { LogLevel, logLevelFromJSON, logLevelToJSON } from "./common.js";

export const protobufPackage = "valka.v1";

/** Worker -> Server */
export interface WorkerRequest {
  hello?: WorkerHello | undefined;
  taskResult?: TaskResult | undefined;
  heartbeat?: Heartbeat | undefined;
  logBatch?: LogBatch | undefined;
  shutdown?: GracefulShutdown | undefined;
  signalAck?: SignalAck | undefined;
}

/** Server -> Worker */
export interface WorkerResponse {
  taskAssignment?: TaskAssignment | undefined;
  taskCancellation?: TaskCancellation | undefined;
  heartbeatAck?: HeartbeatAck | undefined;
  serverShutdown?: ServerShutdown | undefined;
  taskSignal?: TaskSignal | undefined;
}

export interface WorkerHello {
  workerId: string;
  workerName: string;
  queues: string[];
  concurrency: number;
  /** JSON string */
  metadata: string;
}

export interface TaskResult {
  taskId: string;
  taskRunId: string;
  success: boolean;
  retryable: boolean;
  /** JSON string */
  output: string;
  errorMessage: string;
}

export interface Heartbeat {
  activeTaskIds: string[];
  timestampMs: number;
}

export interface LogBatch {
  entries: LogEntry[];
}

export interface LogEntry {
  taskRunId: string;
  timestampMs: number;
  level: LogLevel;
  message: string;
  /** JSON string */
  metadata: string;
}

export interface GracefulShutdown {
  reason: string;
}

export interface TaskAssignment {
  taskId: string;
  taskRunId: string;
  queueName: string;
  taskName: string;
  /** JSON string */
  input: string;
  attemptNumber: number;
  timeoutSeconds: number;
  /** JSON string */
  metadata: string;
}

export interface TaskCancellation {
  taskId: string;
  reason: string;
}

export interface HeartbeatAck {
  serverTimestampMs: number;
}

export interface ServerShutdown {
  reason: string;
  drainSeconds: number;
}

export interface TaskSignal {
  signalId: string;
  taskId: string;
  signalName: string;
  /** JSON string */
  payload: string;
  timestampMs: number;
}

export interface SignalAck {
  signalId: string;
}

function createBaseWorkerRequest(): WorkerRequest {
  return {
    hello: undefined,
    taskResult: undefined,
    heartbeat: undefined,
    logBatch: undefined,
    shutdown: undefined,
    signalAck: undefined,
  };
}

export const WorkerRequest: MessageFns<WorkerRequest> = {
  encode(message: WorkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hello !== undefined) {
      WorkerHello.encode(message.hello, writer.uint32(10).fork()).join();
    }
    if (message.taskResult !== undefined) {
      TaskResult.encode(message.taskResult, writer.uint32(18).fork()).join();
    }
    if (message.heartbeat !== undefined) {
      Heartbeat.encode(message.heartbeat, writer.uint32(26).fork()).join();
    }
    if (message.logBatch !== undefined) {
      LogBatch.encode(message.logBatch, writer.uint32(34).fork()).join();
    }
    if (message.shutdown !== undefined) {
      GracefulShutdown.encode(message.shutdown, writer.uint32(42).fork()).join();
    }
    if (message.signalAck !== undefined) {
      SignalAck.encode(message.signalAck, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hello = WorkerHello.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskResult = TaskResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.heartbeat = Heartbeat.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.logBatch = LogBatch.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shutdown = GracefulShutdown.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signalAck = SignalAck.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerRequest {
    return {
      hello: isSet(object.hello) ? WorkerHello.fromJSON(object.hello) : undefined,
      taskResult: isSet(object.taskResult)
        ? TaskResult.fromJSON(object.taskResult)
        : isSet(object.task_result)
        ? TaskResult.fromJSON(object.task_result)
        : undefined,
      heartbeat: isSet(object.heartbeat) ? Heartbeat.fromJSON(object.heartbeat) : undefined,
      logBatch: isSet(object.logBatch)
        ? LogBatch.fromJSON(object.logBatch)
        : isSet(object.log_batch)
        ? LogBatch.fromJSON(object.log_batch)
        : undefined,
      shutdown: isSet(object.shutdown) ? GracefulShutdown.fromJSON(object.shutdown) : undefined,
      signalAck: isSet(object.signalAck)
        ? SignalAck.fromJSON(object.signalAck)
        : isSet(object.signal_ack)
        ? SignalAck.fromJSON(object.signal_ack)
        : undefined,
    };
  },

  toJSON(message: WorkerRequest): unknown {
    const obj: any = {};
    if (message.hello !== undefined) {
      obj.hello = WorkerHello.toJSON(message.hello);
    }
    if (message.taskResult !== undefined) {
      obj.taskResult = TaskResult.toJSON(message.taskResult);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = Heartbeat.toJSON(message.heartbeat);
    }
    if (message.logBatch !== undefined) {
      obj.logBatch = LogBatch.toJSON(message.logBatch);
    }
    if (message.shutdown !== undefined) {
      obj.shutdown = GracefulShutdown.toJSON(message.shutdown);
    }
    if (message.signalAck !== undefined) {
      obj.signalAck = SignalAck.toJSON(message.signalAck);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerRequest>, I>>(base?: I): WorkerRequest {
    return WorkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerRequest>, I>>(object: I): WorkerRequest {
    const message = createBaseWorkerRequest();
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? WorkerHello.fromPartial(object.hello)
      : undefined;
    message.taskResult = (object.taskResult !== undefined && object.taskResult !== null)
      ? TaskResult.fromPartial(object.taskResult)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? Heartbeat.fromPartial(object.heartbeat)
      : undefined;
    message.logBatch = (object.logBatch !== undefined && object.logBatch !== null)
      ? LogBatch.fromPartial(object.logBatch)
      : undefined;
    message.shutdown = (object.shutdown !== undefined && object.shutdown !== null)
      ? GracefulShutdown.fromPartial(object.shutdown)
      : undefined;
    message.signalAck = (object.signalAck !== undefined && object.signalAck !== null)
      ? SignalAck.fromPartial(object.signalAck)
      : undefined;
    return message;
  },
};

function createBaseWorkerResponse(): WorkerResponse {
  return {
    taskAssignment: undefined,
    taskCancellation: undefined,
    heartbeatAck: undefined,
    serverShutdown: undefined,
    taskSignal: undefined,
  };
}

export const WorkerResponse: MessageFns<WorkerResponse> = {
  encode(message: WorkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskAssignment !== undefined) {
      TaskAssignment.encode(message.taskAssignment, writer.uint32(10).fork()).join();
    }
    if (message.taskCancellation !== undefined) {
      TaskCancellation.encode(message.taskCancellation, writer.uint32(18).fork()).join();
    }
    if (message.heartbeatAck !== undefined) {
      HeartbeatAck.encode(message.heartbeatAck, writer.uint32(26).fork()).join();
    }
    if (message.serverShutdown !== undefined) {
      ServerShutdown.encode(message.serverShutdown, writer.uint32(34).fork()).join();
    }
    if (message.taskSignal !== undefined) {
      TaskSignal.encode(message.taskSignal, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskAssignment = TaskAssignment.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskCancellation = TaskCancellation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.heartbeatAck = HeartbeatAck.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serverShutdown = ServerShutdown.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.taskSignal = TaskSignal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerResponse {
    return {
      taskAssignment: isSet(object.taskAssignment)
        ? TaskAssignment.fromJSON(object.taskAssignment)
        : isSet(object.task_assignment)
        ? TaskAssignment.fromJSON(object.task_assignment)
        : undefined,
      taskCancellation: isSet(object.taskCancellation)
        ? TaskCancellation.fromJSON(object.taskCancellation)
        : isSet(object.task_cancellation)
        ? TaskCancellation.fromJSON(object.task_cancellation)
        : undefined,
      heartbeatAck: isSet(object.heartbeatAck)
        ? HeartbeatAck.fromJSON(object.heartbeatAck)
        : isSet(object.heartbeat_ack)
        ? HeartbeatAck.fromJSON(object.heartbeat_ack)
        : undefined,
      serverShutdown: isSet(object.serverShutdown)
        ? ServerShutdown.fromJSON(object.serverShutdown)
        : isSet(object.server_shutdown)
        ? ServerShutdown.fromJSON(object.server_shutdown)
        : undefined,
      taskSignal: isSet(object.taskSignal)
        ? TaskSignal.fromJSON(object.taskSignal)
        : isSet(object.task_signal)
        ? TaskSignal.fromJSON(object.task_signal)
        : undefined,
    };
  },

  toJSON(message: WorkerResponse): unknown {
    const obj: any = {};
    if (message.taskAssignment !== undefined) {
      obj.taskAssignment = TaskAssignment.toJSON(message.taskAssignment);
    }
    if (message.taskCancellation !== undefined) {
      obj.taskCancellation = TaskCancellation.toJSON(message.taskCancellation);
    }
    if (message.heartbeatAck !== undefined) {
      obj.heartbeatAck = HeartbeatAck.toJSON(message.heartbeatAck);
    }
    if (message.serverShutdown !== undefined) {
      obj.serverShutdown = ServerShutdown.toJSON(message.serverShutdown);
    }
    if (message.taskSignal !== undefined) {
      obj.taskSignal = TaskSignal.toJSON(message.taskSignal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerResponse>, I>>(base?: I): WorkerResponse {
    return WorkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerResponse>, I>>(object: I): WorkerResponse {
    const message = createBaseWorkerResponse();
    message.taskAssignment = (object.taskAssignment !== undefined && object.taskAssignment !== null)
      ? TaskAssignment.fromPartial(object.taskAssignment)
      : undefined;
    message.taskCancellation = (object.taskCancellation !== undefined && object.taskCancellation !== null)
      ? TaskCancellation.fromPartial(object.taskCancellation)
      : undefined;
    message.heartbeatAck = (object.heartbeatAck !== undefined && object.heartbeatAck !== null)
      ? HeartbeatAck.fromPartial(object.heartbeatAck)
      : undefined;
    message.serverShutdown = (object.serverShutdown !== undefined && object.serverShutdown !== null)
      ? ServerShutdown.fromPartial(object.serverShutdown)
      : undefined;
    message.taskSignal = (object.taskSignal !== undefined && object.taskSignal !== null)
      ? TaskSignal.fromPartial(object.taskSignal)
      : undefined;
    return message;
  },
};

function createBaseWorkerHello(): WorkerHello {
  return { workerId: "", workerName: "", queues: [], concurrency: 0, metadata: "" };
}

export const WorkerHello: MessageFns<WorkerHello> = {
  encode(message: WorkerHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== "") {
      writer.uint32(10).string(message.workerId);
    }
    if (message.workerName !== "") {
      writer.uint32(18).string(message.workerName);
    }
    for (const v of message.queues) {
      writer.uint32(26).string(v!);
    }
    if (message.concurrency !== 0) {
      writer.uint32(32).int32(message.concurrency);
    }
    if (message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.queues.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.concurrency = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerHello {
    return {
      workerId: isSet(object.workerId)
        ? globalThis.String(object.workerId)
        : isSet(object.worker_id)
        ? globalThis.String(object.worker_id)
        : "",
      workerName: isSet(object.workerName)
        ? globalThis.String(object.workerName)
        : isSet(object.worker_name)
        ? globalThis.String(object.worker_name)
        : "",
      queues: globalThis.Array.isArray(object?.queues) ? object.queues.map((e: any) => globalThis.String(e)) : [],
      concurrency: isSet(object.concurrency) ? globalThis.Number(object.concurrency) : 0,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
    };
  },

  toJSON(message: WorkerHello): unknown {
    const obj: any = {};
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.workerName !== "") {
      obj.workerName = message.workerName;
    }
    if (message.queues?.length) {
      obj.queues = message.queues;
    }
    if (message.concurrency !== 0) {
      obj.concurrency = Math.round(message.concurrency);
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerHello>, I>>(base?: I): WorkerHello {
    return WorkerHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerHello>, I>>(object: I): WorkerHello {
    const message = createBaseWorkerHello();
    message.workerId = object.workerId ?? "";
    message.workerName = object.workerName ?? "";
    message.queues = object.queues?.map((e) => e) || [];
    message.concurrency = object.concurrency ?? 0;
    message.metadata = object.metadata ?? "";
    return message;
  },
};

function createBaseTaskResult(): TaskResult {
  return { taskId: "", taskRunId: "", success: false, retryable: false, output: "", errorMessage: "" };
}

export const TaskResult: MessageFns<TaskResult> = {
  encode(message: TaskResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.taskRunId !== "") {
      writer.uint32(18).string(message.taskRunId);
    }
    if (message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.retryable !== false) {
      writer.uint32(32).bool(message.retryable);
    }
    if (message.output !== "") {
      writer.uint32(42).string(message.output);
    }
    if (message.errorMessage !== "") {
      writer.uint32(50).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskRunId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.retryable = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskResult {
    return {
      taskId: isSet(object.taskId)
        ? globalThis.String(object.taskId)
        : isSet(object.task_id)
        ? globalThis.String(object.task_id)
        : "",
      taskRunId: isSet(object.taskRunId)
        ? globalThis.String(object.taskRunId)
        : isSet(object.task_run_id)
        ? globalThis.String(object.task_run_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      retryable: isSet(object.retryable) ? globalThis.Boolean(object.retryable) : false,
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
    };
  },

  toJSON(message: TaskResult): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.taskRunId !== "") {
      obj.taskRunId = message.taskRunId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.retryable !== false) {
      obj.retryable = message.retryable;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskResult>, I>>(base?: I): TaskResult {
    return TaskResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskResult>, I>>(object: I): TaskResult {
    const message = createBaseTaskResult();
    message.taskId = object.taskId ?? "";
    message.taskRunId = object.taskRunId ?? "";
    message.success = object.success ?? false;
    message.retryable = object.retryable ?? false;
    message.output = object.output ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseHeartbeat(): Heartbeat {
  return { activeTaskIds: [], timestampMs: 0 };
}

export const Heartbeat: MessageFns<Heartbeat> = {
  encode(message: Heartbeat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.activeTaskIds) {
      writer.uint32(10).string(v!);
    }
    if (message.timestampMs !== 0) {
      writer.uint32(16).int64(message.timestampMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Heartbeat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.activeTaskIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestampMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Heartbeat {
    return {
      activeTaskIds: globalThis.Array.isArray(object?.activeTaskIds)
        ? object.activeTaskIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.active_task_ids)
        ? object.active_task_ids.map((e: any) => globalThis.String(e))
        : [],
      timestampMs: isSet(object.timestampMs)
        ? globalThis.Number(object.timestampMs)
        : isSet(object.timestamp_ms)
        ? globalThis.Number(object.timestamp_ms)
        : 0,
    };
  },

  toJSON(message: Heartbeat): unknown {
    const obj: any = {};
    if (message.activeTaskIds?.length) {
      obj.activeTaskIds = message.activeTaskIds;
    }
    if (message.timestampMs !== 0) {
      obj.timestampMs = Math.round(message.timestampMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Heartbeat>, I>>(base?: I): Heartbeat {
    return Heartbeat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Heartbeat>, I>>(object: I): Heartbeat {
    const message = createBaseHeartbeat();
    message.activeTaskIds = object.activeTaskIds?.map((e) => e) || [];
    message.timestampMs = object.timestampMs ?? 0;
    return message;
  },
};

function createBaseLogBatch(): LogBatch {
  return { entries: [] };
}

export const LogBatch: MessageFns<LogBatch> = {
  encode(message: LogBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      LogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(LogEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogBatch {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => LogEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: LogBatch): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => LogEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogBatch>, I>>(base?: I): LogBatch {
    return LogBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogBatch>, I>>(object: I): LogBatch {
    const message = createBaseLogBatch();
    message.entries = object.entries?.map((e) => LogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLogEntry(): LogEntry {
  return { taskRunId: "", timestampMs: 0, level: 0, message: "", metadata: "" };
}

export const LogEntry: MessageFns<LogEntry> = {
  encode(message: LogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskRunId !== "") {
      writer.uint32(10).string(message.taskRunId);
    }
    if (message.timestampMs !== 0) {
      writer.uint32(16).int64(message.timestampMs);
    }
    if (message.level !== 0) {
      writer.uint32(24).int32(message.level);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskRunId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestampMs = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntry {
    return {
      taskRunId: isSet(object.taskRunId)
        ? globalThis.String(object.taskRunId)
        : isSet(object.task_run_id)
        ? globalThis.String(object.task_run_id)
        : "",
      timestampMs: isSet(object.timestampMs)
        ? globalThis.Number(object.timestampMs)
        : isSet(object.timestamp_ms)
        ? globalThis.Number(object.timestamp_ms)
        : 0,
      level: isSet(object.level) ? logLevelFromJSON(object.level) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
    };
  },

  toJSON(message: LogEntry): unknown {
    const obj: any = {};
    if (message.taskRunId !== "") {
      obj.taskRunId = message.taskRunId;
    }
    if (message.timestampMs !== 0) {
      obj.timestampMs = Math.round(message.timestampMs);
    }
    if (message.level !== 0) {
      obj.level = logLevelToJSON(message.level);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEntry>, I>>(base?: I): LogEntry {
    return LogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEntry>, I>>(object: I): LogEntry {
    const message = createBaseLogEntry();
    message.taskRunId = object.taskRunId ?? "";
    message.timestampMs = object.timestampMs ?? 0;
    message.level = object.level ?? 0;
    message.message = object.message ?? "";
    message.metadata = object.metadata ?? "";
    return message;
  },
};

function createBaseGracefulShutdown(): GracefulShutdown {
  return { reason: "" };
}

export const GracefulShutdown: MessageFns<GracefulShutdown> = {
  encode(message: GracefulShutdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GracefulShutdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGracefulShutdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GracefulShutdown {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: GracefulShutdown): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GracefulShutdown>, I>>(base?: I): GracefulShutdown {
    return GracefulShutdown.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GracefulShutdown>, I>>(object: I): GracefulShutdown {
    const message = createBaseGracefulShutdown();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseTaskAssignment(): TaskAssignment {
  return {
    taskId: "",
    taskRunId: "",
    queueName: "",
    taskName: "",
    input: "",
    attemptNumber: 0,
    timeoutSeconds: 0,
    metadata: "",
  };
}

export const TaskAssignment: MessageFns<TaskAssignment> = {
  encode(message: TaskAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.taskRunId !== "") {
      writer.uint32(18).string(message.taskRunId);
    }
    if (message.queueName !== "") {
      writer.uint32(26).string(message.queueName);
    }
    if (message.taskName !== "") {
      writer.uint32(34).string(message.taskName);
    }
    if (message.input !== "") {
      writer.uint32(42).string(message.input);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(48).int32(message.attemptNumber);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(56).int32(message.timeoutSeconds);
    }
    if (message.metadata !== "") {
      writer.uint32(66).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskRunId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.queueName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.taskName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskAssignment {
    return {
      taskId: isSet(object.taskId)
        ? globalThis.String(object.taskId)
        : isSet(object.task_id)
        ? globalThis.String(object.task_id)
        : "",
      taskRunId: isSet(object.taskRunId)
        ? globalThis.String(object.taskRunId)
        : isSet(object.task_run_id)
        ? globalThis.String(object.task_run_id)
        : "",
      queueName: isSet(object.queueName)
        ? globalThis.String(object.queueName)
        : isSet(object.queue_name)
        ? globalThis.String(object.queue_name)
        : "",
      taskName: isSet(object.taskName)
        ? globalThis.String(object.taskName)
        : isSet(object.task_name)
        ? globalThis.String(object.task_name)
        : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      attemptNumber: isSet(object.attemptNumber)
        ? globalThis.Number(object.attemptNumber)
        : isSet(object.attempt_number)
        ? globalThis.Number(object.attempt_number)
        : 0,
      timeoutSeconds: isSet(object.timeoutSeconds)
        ? globalThis.Number(object.timeoutSeconds)
        : isSet(object.timeout_seconds)
        ? globalThis.Number(object.timeout_seconds)
        : 0,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
    };
  },

  toJSON(message: TaskAssignment): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.taskRunId !== "") {
      obj.taskRunId = message.taskRunId;
    }
    if (message.queueName !== "") {
      obj.queueName = message.queueName;
    }
    if (message.taskName !== "") {
      obj.taskName = message.taskName;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.attemptNumber !== 0) {
      obj.attemptNumber = Math.round(message.attemptNumber);
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskAssignment>, I>>(base?: I): TaskAssignment {
    return TaskAssignment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskAssignment>, I>>(object: I): TaskAssignment {
    const message = createBaseTaskAssignment();
    message.taskId = object.taskId ?? "";
    message.taskRunId = object.taskRunId ?? "";
    message.queueName = object.queueName ?? "";
    message.taskName = object.taskName ?? "";
    message.input = object.input ?? "";
    message.attemptNumber = object.attemptNumber ?? 0;
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.metadata = object.metadata ?? "";
    return message;
  },
};

function createBaseTaskCancellation(): TaskCancellation {
  return { taskId: "", reason: "" };
}

export const TaskCancellation: MessageFns<TaskCancellation> = {
  encode(message: TaskCancellation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskCancellation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskCancellation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskCancellation {
    return {
      taskId: isSet(object.taskId)
        ? globalThis.String(object.taskId)
        : isSet(object.task_id)
        ? globalThis.String(object.task_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: TaskCancellation): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskCancellation>, I>>(base?: I): TaskCancellation {
    return TaskCancellation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskCancellation>, I>>(object: I): TaskCancellation {
    const message = createBaseTaskCancellation();
    message.taskId = object.taskId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseHeartbeatAck(): HeartbeatAck {
  return { serverTimestampMs: 0 };
}

export const HeartbeatAck: MessageFns<HeartbeatAck> = {
  encode(message: HeartbeatAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverTimestampMs !== 0) {
      writer.uint32(8).int64(message.serverTimestampMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.serverTimestampMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatAck {
    return {
      serverTimestampMs: isSet(object.serverTimestampMs)
        ? globalThis.Number(object.serverTimestampMs)
        : isSet(object.server_timestamp_ms)
        ? globalThis.Number(object.server_timestamp_ms)
        : 0,
    };
  },

  toJSON(message: HeartbeatAck): unknown {
    const obj: any = {};
    if (message.serverTimestampMs !== 0) {
      obj.serverTimestampMs = Math.round(message.serverTimestampMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatAck>, I>>(base?: I): HeartbeatAck {
    return HeartbeatAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatAck>, I>>(object: I): HeartbeatAck {
    const message = createBaseHeartbeatAck();
    message.serverTimestampMs = object.serverTimestampMs ?? 0;
    return message;
  },
};

function createBaseServerShutdown(): ServerShutdown {
  return { reason: "", drainSeconds: 0 };
}

export const ServerShutdown: MessageFns<ServerShutdown> = {
  encode(message: ServerShutdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    if (message.drainSeconds !== 0) {
      writer.uint32(16).int32(message.drainSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerShutdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerShutdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.drainSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerShutdown {
    return {
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      drainSeconds: isSet(object.drainSeconds)
        ? globalThis.Number(object.drainSeconds)
        : isSet(object.drain_seconds)
        ? globalThis.Number(object.drain_seconds)
        : 0,
    };
  },

  toJSON(message: ServerShutdown): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.drainSeconds !== 0) {
      obj.drainSeconds = Math.round(message.drainSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerShutdown>, I>>(base?: I): ServerShutdown {
    return ServerShutdown.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerShutdown>, I>>(object: I): ServerShutdown {
    const message = createBaseServerShutdown();
    message.reason = object.reason ?? "";
    message.drainSeconds = object.drainSeconds ?? 0;
    return message;
  },
};

function createBaseTaskSignal(): TaskSignal {
  return { signalId: "", taskId: "", signalName: "", payload: "", timestampMs: 0 };
}

export const TaskSignal: MessageFns<TaskSignal> = {
  encode(message: TaskSignal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signalId !== "") {
      writer.uint32(10).string(message.signalId);
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    if (message.signalName !== "") {
      writer.uint32(26).string(message.signalName);
    }
    if (message.payload !== "") {
      writer.uint32(34).string(message.payload);
    }
    if (message.timestampMs !== 0) {
      writer.uint32(40).int64(message.timestampMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskSignal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskSignal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signalId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signalName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestampMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskSignal {
    return {
      signalId: isSet(object.signalId)
        ? globalThis.String(object.signalId)
        : isSet(object.signal_id)
        ? globalThis.String(object.signal_id)
        : "",
      taskId: isSet(object.taskId)
        ? globalThis.String(object.taskId)
        : isSet(object.task_id)
        ? globalThis.String(object.task_id)
        : "",
      signalName: isSet(object.signalName)
        ? globalThis.String(object.signalName)
        : isSet(object.signal_name)
        ? globalThis.String(object.signal_name)
        : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      timestampMs: isSet(object.timestampMs)
        ? globalThis.Number(object.timestampMs)
        : isSet(object.timestamp_ms)
        ? globalThis.Number(object.timestamp_ms)
        : 0,
    };
  },

  toJSON(message: TaskSignal): unknown {
    const obj: any = {};
    if (message.signalId !== "") {
      obj.signalId = message.signalId;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.signalName !== "") {
      obj.signalName = message.signalName;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.timestampMs !== 0) {
      obj.timestampMs = Math.round(message.timestampMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskSignal>, I>>(base?: I): TaskSignal {
    return TaskSignal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskSignal>, I>>(object: I): TaskSignal {
    const message = createBaseTaskSignal();
    message.signalId = object.signalId ?? "";
    message.taskId = object.taskId ?? "";
    message.signalName = object.signalName ?? "";
    message.payload = object.payload ?? "";
    message.timestampMs = object.timestampMs ?? 0;
    return message;
  },
};

function createBaseSignalAck(): SignalAck {
  return { signalId: "" };
}

export const SignalAck: MessageFns<SignalAck> = {
  encode(message: SignalAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signalId !== "") {
      writer.uint32(10).string(message.signalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalAck {
    return {
      signalId: isSet(object.signalId)
        ? globalThis.String(object.signalId)
        : isSet(object.signal_id)
        ? globalThis.String(object.signal_id)
        : "",
    };
  },

  toJSON(message: SignalAck): unknown {
    const obj: any = {};
    if (message.signalId !== "") {
      obj.signalId = message.signalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalAck>, I>>(base?: I): SignalAck {
    return SignalAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalAck>, I>>(object: I): SignalAck {
    const message = createBaseSignalAck();
    message.signalId = object.signalId ?? "";
    return message;
  },
};

export type WorkerServiceDefinition = typeof WorkerServiceDefinition;
export const WorkerServiceDefinition = {
  name: "WorkerService",
  fullName: "valka.v1.WorkerService",
  methods: {
    /** Primary bidirectional stream for ALL worker communication */
    session: {
      name: "Session",
      requestType: WorkerRequest,
      requestStream: true,
      responseType: WorkerResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface WorkerServiceImplementation<CallContextExt = {}> {
  /** Primary bidirectional stream for ALL worker communication */
  session(
    request: AsyncIterable<WorkerRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<WorkerResponse>>;
}

export interface WorkerServiceClient<CallOptionsExt = {}> {
  /** Primary bidirectional stream for ALL worker communication */
  session(
    request: AsyncIterable<DeepPartial<WorkerRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<WorkerResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
