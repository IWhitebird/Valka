---
title: Introduction
description: What is Valka and why does it exist?
---

## What is Valka?

Valka is a **distributed task queue** built entirely in Rust with a single external dependency: **PostgreSQL**.

Most task queues bolt together a message broker, a database, and a cache. Every moving part is another thing to deploy, monitor, and debug at 3 AM. Valka takes a different approach — PostgreSQL is the single source of truth, and an in-memory matching engine with gRPC bidirectional streaming replaces the message broker entirely.

The result: simple to operate, easy to reason about, and fast where it matters.

## Key Features

- **One dependency** — If you have Postgres, you can run Valka
- **Zero-latency hot path** — Tasks are matched to waiting workers in-memory, no polling
- **Polyglot SDKs** — Rust, TypeScript, Go, and Python with the same builder pattern
- **gRPC bidirectional streaming** — Single connection per worker, real-time task delivery
- **Automatic retries** — Exponential backoff with dead letter queue
- **Task signals** — Send real-time signals to running workers
- **Observable** — Real-time log streaming, event feeds, Prometheus metrics, web dashboard
- **Multi-node clustering** — chitchat gossip + consistent hash ring
- **Idempotency keys** — Prevent duplicate task execution
- **Scheduled tasks** — Delayed and deferred task execution

## How It Works

<Mermaid chart={`graph TD
    C[REST / gRPC Client] --> MS[MatchingService<br/>Partition Tree]

    MS --> HP[Hot Path<br/>In-Memory Oneshot]
    MS --> CP[Cold Path<br/>PG SKIP LOCKED]

    HP --> D[Dispatcher<br/>gRPC Bidi Stream]
    CP --> D

    D --> W1[Worker A]
    D --> W2[Worker B]
    D --> W3[Worker C]

    style MS fill:#4f46e5,stroke:#6366f1,color:#fff
    style HP fill:#059669,stroke:#10b981,color:#fff
    style CP fill:#0284c7,stroke:#38bdf8,color:#fff
    style D fill:#7c3aed,stroke:#8b5cf6,color:#fff
`} />

**Hot path**: When a task is created and a worker is already waiting, the task is matched in-memory via a oneshot channel and pushed over the gRPC stream instantly.

**Cold path**: When no worker is waiting, the task is persisted to PostgreSQL. Workers poll using `SKIP LOCKED` to claim tasks without contention.

## SDKs

| Language | Package | Install |
|----------|---------|---------|
| **Rust** | `valka-sdk` | `cargo add valka-sdk` |
| **TypeScript** | `@valka/sdk` | `npm install @valka/sdk` |
| **Go** | `github.com/IWhitebird/Valka/sdks/go` | `go get github.com/IWhitebird/Valka/sdks/go` |
| **Python** | `valka` | `pip install valka` |

Any language can also interact via the REST API on port `8989`.

## Next Steps

- [Quick Start](/docs/quick-start) — Get Valka running in minutes
- [Architecture](/docs/architecture) — Deep dive into how Valka works
- [Task Lifecycle](/docs/task-lifecycle) — Understand task states and transitions
